includes

 - At an #include (and include_next,import) directive, we need to record the
   full path of the included file, and the source range of the filename.
   (Can we say that the file is a symbol, then record a ref to it?)

Find more user-friendly symbol names than USRs.

 - Do USRs go away entirely?  Is there a one-to-one or a one-to-many
   relationship between a USR and a user-friendly name?  If USRs are still
   present, then will their existence make navigator behavior magical/opaque?

Template arguments

 - Instead of recording a std::vector<Foo*, std::allocator<Foo*>>, we can
   record one of:
    - std::vector
    - std::vector<Foo*>
   I'm not aware of a downside to omitting template arguments that match the
   default.  I'm not sure it's really feasible.  Omitting the template arguments
   entirely has the advantage of reducing the number of symbols at a single
   source point (but it doesn't solve the problem -- consider preprocessor
   usage).  It means that I could xref on std::vector::push_back to see all uses
   of that method regardless of the contained type.

Ref ranges

 - For refs, try to get range info (start+stop) rather than just a location.
   This is needed for C++ destructors because "~ Foo" is not an identifier, but
   we'd probably like the whole thing to be treated like one.  (Actually, can
   there be comments in there?)

Highlighting

 - For highlighting, we want to differentiate between kinds of symbols:
    - types
    - members
    - local variables

Bugs (bad ref kinds)

 - For "class A : T<A>" we record A as a Base-Class.  It should be something
   else, maybe just Reference.
 - See notes/misc for more.

Special buffers (scratch space, built-in macros)

 - I keep seeing references to "<scratch space>" and "<built-in>".  They ought
   to go away.  Maybe some of the scratch space references have something to
   do with the preprocessor and with the way the indexer deals with macros
   and source locations.

 - For "<built-in>" (and command-line -D/-U args?), the ideal fix probably goes
   like this.  We'd have a special table ("builtins") mapping USRs for built-in
   macro definitions to a string with the expanded tokens.  Then at some point,
   we'd read this table and turn it into a special buffer.  Something like this:
      /*built-in*/ FOO => 1
      /*built-in*/ FOO => 0
      /*cmd-line*/ FOO => 1
      /*cmd-line*/ FOO => undef
      /*built-in*/ #define BAR 1
      /*built-in*/ #define BAZ 1
   We could do this transformation right before writing the completed index
   file, or we could do in the navigator itself.  Each line in the special
   buffer implies one extra ref.  (I assume the values themselves don't refer
   to other macros, but I don't know that for sure.)  If the transformation is
   done at index time, then we can create the refs then, but we need to store
   the buffer in the index ("special-buffers" table, with one column mapping
   "<built-in>" to the content?).  If the transformation is done at run-time,
   then the navigator will have to augment the ref query to add in the built-in
   refs.

   DECISION: I think the transformation should be done at index-time so as to
   keep more C/C++-specific code out of the navigator.

----

For C++, include parameter type names to handle overloading:

std::vector::push_back(A*)

For symbols with internal linkage:

    basename.h/static_function
    basename.h/foo::<anon>::function

Templates: -- omit the template params entirely

    PROBLEM: What about function overloading?  Suppose there are two
    functions:
        int func(std::vector<int> &vi)
        int func(std::vector<double &vd)
    Would we represent both as this?
        func(std::vector&)

----

Problem at llvm/include/llvm/ADT/SmallVector.h, lines 273.
There is no ref on SmallVectorTemplateBase or value.

    class SmallVectorImpl : public SmallVectorTemplateBase<T, isPodLike<T>::value> {

----

New uint32_t encoding:

0xxxxxxx
10xxxxxx xxxxxxxx
110xxxxx xxxxxxxx xxxxxxxx
1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx
1111000x xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx

This variable-length encoding ensures that a sequence of numbers has the same
order as its encoded byte-string (which is the concatenation of the VLE-encoded
numbers).

Each xxxxxxxx represents 255 values rather than 256, to avoid NUL bytes.  This
will require division to encode a number and multiplication to decode a number.

The encoding handles the values [0..2**32-1].  To encode zero without using a
NUL byte, one is added to the value before encoding it.

----

Calls to the clang::VarDecl(Kind, DeclContext, ...) ctor seem to be missing
from the refs info.  Also review whether calls to dtors are in the refs info.
This might be a difficult thing to fix -- a lot of these calls are implicit.
Image what happens with std::vector<SomeType> -- where are calls to
SomeType::~SomeType coming from?  Implicit conversions are probably related.

----

This is probably mentioned elsewhere, but record it here anyway.  The Curiously
Recurring Template Pattern appears repeatedly in LLVM+Clang, and the Derived
class appears as a Base-Class ref.  It should appear as just a Reference.

----

    // TODO: On second thought, I now think two changes should be made:
    //  * The location->symbol table should also include a reftype, and it
    //    should become the primary table (i.e. it should exist in the TU
    //    indices, rather than the symbol->reference table).  The
    //    symbol->reference table is really an "inverted index".
    //  * Treating an include as a kind of reference in the source code makes
    //    enough sense to avoid duplicating the tables.  If they're duplicated,
    //    they'll just have to be smashed back together in the navigator.
    // The SymbolType for each path symbol should be either File or Path.
    // The idea that we need these separate tables for an efficient include
    // graph is weakened by the idea that an #include-reference might refer to
    // a filename provided by a macro in a different file.  e.g.:
    //
    // file1.h
    //    #define FILE2 "file2.h"
    // file1.c
    //    #include "file1.h"
    //    #include FILE2
    //
    // FILE2 will be associated with the macro defined in file1.h.  It is
    // reasonable (and my currently planned action) to associate the file2.h
    // inclusion with the "file2.h" string literal rather than with something
    // in file1.c.
